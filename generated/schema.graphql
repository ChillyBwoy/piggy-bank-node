# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumProposalStatusFilter {
  equals: ProposalStatus
  in: [ProposalStatus!]
  not: NestedEnumProposalStatusFilter
  notIn: [ProposalStatus!]
}

input EnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

type Mutation {
  createOwnership(data: OwnershipCreateInput!): Ownership!
  createProposal(data: ProposalCreateInput!): Proposal!
  createService(data: ServiceCreateInput!): Service!
  createVote(data: VoteCreateInput!): Vote!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumProposalStatusFilter {
  equals: ProposalStatus
  in: [ProposalStatus!]
  not: NestedEnumProposalStatusFilter
  notIn: [ProposalStatus!]
}

input NestedEnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Ownership {
  role: UserRole!
  service: Service!
  serviceId: String!
  user: User!
  userId: String!
}

input OwnershipCreateInput {
  role: UserRole!
  service: ServiceCreateNestedOneWithoutOwnersInput!
  user: UserCreateNestedOneWithoutServicesInput!
}

input OwnershipCreateManyServiceInput {
  role: UserRole!
  userId: String!
}

input OwnershipCreateManyServiceInputEnvelope {
  data: [OwnershipCreateManyServiceInput!]!
  skipDuplicates: Boolean
}

input OwnershipCreateManyUserInput {
  role: UserRole!
  serviceId: String!
}

input OwnershipCreateManyUserInputEnvelope {
  data: [OwnershipCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input OwnershipCreateNestedManyWithoutServiceInput {
  connect: [OwnershipWhereUniqueInput!]
  connectOrCreate: [OwnershipCreateOrConnectWithoutServiceInput!]
  create: [OwnershipCreateWithoutServiceInput!]
  createMany: OwnershipCreateManyServiceInputEnvelope
}

input OwnershipCreateNestedManyWithoutUserInput {
  connect: [OwnershipWhereUniqueInput!]
  connectOrCreate: [OwnershipCreateOrConnectWithoutUserInput!]
  create: [OwnershipCreateWithoutUserInput!]
  createMany: OwnershipCreateManyUserInputEnvelope
}

input OwnershipCreateOrConnectWithoutServiceInput {
  create: OwnershipCreateWithoutServiceInput!
  where: OwnershipWhereUniqueInput!
}

input OwnershipCreateOrConnectWithoutUserInput {
  create: OwnershipCreateWithoutUserInput!
  where: OwnershipWhereUniqueInput!
}

input OwnershipCreateWithoutServiceInput {
  role: UserRole!
  user: UserCreateNestedOneWithoutServicesInput!
}

input OwnershipCreateWithoutUserInput {
  role: UserRole!
  service: ServiceCreateNestedOneWithoutOwnersInput!
}

input OwnershipListRelationFilter {
  every: OwnershipWhereInput
  none: OwnershipWhereInput
  some: OwnershipWhereInput
}

input OwnershipOrderByInput {
  role: SortOrder
  serviceId: SortOrder
  userId: SortOrder
}

enum OwnershipScalarFieldEnum {
  role
  serviceId
  userId
}

input OwnershipUserIdServiceIdCompoundUniqueInput {
  serviceId: String!
  userId: String!
}

input OwnershipWhereInput {
  AND: [OwnershipWhereInput!]
  NOT: [OwnershipWhereInput!]
  OR: [OwnershipWhereInput!]
  role: EnumUserRoleFilter
  service: ServiceRelationFilter
  serviceId: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input OwnershipWhereUniqueInput {
  userId_serviceId: OwnershipUserIdServiceIdCompoundUniqueInput
}

type Proposal {
  Vote(cursor: VoteWhereUniqueInput, distinct: [VoteScalarFieldEnum!], orderBy: [VoteOrderByInput!], skip: Int, take: Int, where: VoteWhereInput): [Vote!]!
  author: User!
  authorId: String!
  createdAt: DateTime!
  description: String!
  service: Service!
  serviceId: String!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalAuthorIdServiceIdCompoundUniqueInput {
  authorId: String!
  serviceId: String!
}

input ProposalCreateInput {
  Vote: VoteCreateNestedManyWithoutProposalInput
  author: UserCreateNestedOneWithoutProposalsInput!
  createdAt: DateTime!
  description: String!
  service: ServiceCreateNestedOneWithoutProposalsInput!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalCreateManyAuthorInput {
  createdAt: DateTime!
  description: String!
  serviceId: String!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalCreateManyAuthorInputEnvelope {
  data: [ProposalCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input ProposalCreateManyServiceInput {
  authorId: String!
  createdAt: DateTime!
  description: String!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalCreateManyServiceInputEnvelope {
  data: [ProposalCreateManyServiceInput!]!
  skipDuplicates: Boolean
}

input ProposalCreateNestedManyWithoutAuthorInput {
  connect: [ProposalWhereUniqueInput!]
  connectOrCreate: [ProposalCreateOrConnectWithoutAuthorInput!]
  create: [ProposalCreateWithoutAuthorInput!]
  createMany: ProposalCreateManyAuthorInputEnvelope
}

input ProposalCreateNestedManyWithoutServiceInput {
  connect: [ProposalWhereUniqueInput!]
  connectOrCreate: [ProposalCreateOrConnectWithoutServiceInput!]
  create: [ProposalCreateWithoutServiceInput!]
  createMany: ProposalCreateManyServiceInputEnvelope
}

input ProposalCreateNestedOneWithoutVoteInput {
  connect: ProposalWhereUniqueInput
  connectOrCreate: ProposalCreateOrConnectWithoutVoteInput
  create: ProposalCreateWithoutVoteInput
}

input ProposalCreateOrConnectWithoutAuthorInput {
  create: ProposalCreateWithoutAuthorInput!
  where: ProposalWhereUniqueInput!
}

input ProposalCreateOrConnectWithoutServiceInput {
  create: ProposalCreateWithoutServiceInput!
  where: ProposalWhereUniqueInput!
}

input ProposalCreateOrConnectWithoutVoteInput {
  create: ProposalCreateWithoutVoteInput!
  where: ProposalWhereUniqueInput!
}

input ProposalCreateWithoutAuthorInput {
  Vote: VoteCreateNestedManyWithoutProposalInput
  createdAt: DateTime!
  description: String!
  service: ServiceCreateNestedOneWithoutProposalsInput!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalCreateWithoutServiceInput {
  Vote: VoteCreateNestedManyWithoutProposalInput
  author: UserCreateNestedOneWithoutProposalsInput!
  createdAt: DateTime!
  description: String!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalCreateWithoutVoteInput {
  author: UserCreateNestedOneWithoutProposalsInput!
  createdAt: DateTime!
  description: String!
  service: ServiceCreateNestedOneWithoutProposalsInput!
  status: ProposalStatus!
  updatedat: DateTime!
}

input ProposalListRelationFilter {
  every: ProposalWhereInput
  none: ProposalWhereInput
  some: ProposalWhereInput
}

input ProposalOrderByInput {
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  serviceId: SortOrder
  status: SortOrder
  updatedat: SortOrder
}

input ProposalRelationFilter {
  is: ProposalWhereInput
  isNot: ProposalWhereInput
}

enum ProposalScalarFieldEnum {
  authorId
  createdAt
  description
  serviceId
  status
  updatedat
}

enum ProposalStatus {
  APPROVED
  PENDING
  REJECTED
}

input ProposalWhereInput {
  AND: [ProposalWhereInput!]
  NOT: [ProposalWhereInput!]
  OR: [ProposalWhereInput!]
  Vote: VoteListRelationFilter
  author: UserRelationFilter
  authorId: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  service: ServiceRelationFilter
  serviceId: StringFilter
  status: EnumProposalStatusFilter
  updatedat: DateTimeFilter
}

input ProposalWhereUniqueInput {
  authorId_serviceId: ProposalAuthorIdServiceIdCompoundUniqueInput
}

type Query {
  ownership(where: OwnershipWhereUniqueInput!): Ownership
  proposal(where: ProposalWhereUniqueInput!): Proposal
  proposals(cursor: ProposalWhereUniqueInput, distinct: [ProposalScalarFieldEnum!], orderBy: [ProposalOrderByInput!], skip: Int, take: Int, where: ProposalWhereInput): [Proposal!]!
  service(where: ServiceWhereUniqueInput!): Service
  services(cursor: ServiceWhereUniqueInput, distinct: [ServiceScalarFieldEnum!], orderBy: [ServiceOrderByInput!], skip: Int, take: Int, where: ServiceWhereInput): [Service!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  vote(where: VoteWhereUniqueInput!): Vote
  votes(cursor: VoteWhereUniqueInput, distinct: [VoteScalarFieldEnum!], orderBy: [VoteOrderByInput!], skip: Int, take: Int, where: VoteWhereInput): [Vote!]!
}

enum QueryMode {
  default
  insensitive
}

type Service {
  id: String!
  name: String!
  owners(cursor: OwnershipWhereUniqueInput, distinct: [OwnershipScalarFieldEnum!], orderBy: [OwnershipOrderByInput!], skip: Int, take: Int, where: OwnershipWhereInput): [Ownership!]!
  proposals(cursor: ProposalWhereUniqueInput, distinct: [ProposalScalarFieldEnum!], orderBy: [ProposalOrderByInput!], skip: Int, take: Int, where: ProposalWhereInput): [Proposal!]!
}

input ServiceCreateInput {
  id: String
  name: String!
  owners: OwnershipCreateNestedManyWithoutServiceInput
  proposals: ProposalCreateNestedManyWithoutServiceInput
}

input ServiceCreateNestedOneWithoutOwnersInput {
  connect: ServiceWhereUniqueInput
  connectOrCreate: ServiceCreateOrConnectWithoutOwnersInput
  create: ServiceCreateWithoutOwnersInput
}

input ServiceCreateNestedOneWithoutProposalsInput {
  connect: ServiceWhereUniqueInput
  connectOrCreate: ServiceCreateOrConnectWithoutProposalsInput
  create: ServiceCreateWithoutProposalsInput
}

input ServiceCreateOrConnectWithoutOwnersInput {
  create: ServiceCreateWithoutOwnersInput!
  where: ServiceWhereUniqueInput!
}

input ServiceCreateOrConnectWithoutProposalsInput {
  create: ServiceCreateWithoutProposalsInput!
  where: ServiceWhereUniqueInput!
}

input ServiceCreateWithoutOwnersInput {
  id: String
  name: String!
  proposals: ProposalCreateNestedManyWithoutServiceInput
}

input ServiceCreateWithoutProposalsInput {
  id: String
  name: String!
  owners: OwnershipCreateNestedManyWithoutServiceInput
}

input ServiceOrderByInput {
  id: SortOrder
  name: SortOrder
}

input ServiceRelationFilter {
  is: ServiceWhereInput
  isNot: ServiceWhereInput
}

enum ServiceScalarFieldEnum {
  id
  name
}

input ServiceWhereInput {
  AND: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  id: StringFilter
  name: StringFilter
  owners: OwnershipListRelationFilter
  proposals: ProposalListRelationFilter
}

input ServiceWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type User {
  id: String!
  name: String!
  proposals(cursor: ProposalWhereUniqueInput, distinct: [ProposalScalarFieldEnum!], orderBy: [ProposalOrderByInput!], skip: Int, take: Int, where: ProposalWhereInput): [Proposal!]!
  services(cursor: OwnershipWhereUniqueInput, distinct: [OwnershipScalarFieldEnum!], orderBy: [OwnershipOrderByInput!], skip: Int, take: Int, where: OwnershipWhereInput): [Ownership!]!
  votes(cursor: VoteWhereUniqueInput, distinct: [VoteScalarFieldEnum!], orderBy: [VoteOrderByInput!], skip: Int, take: Int, where: VoteWhereInput): [Vote!]!
}

input UserCreateNestedOneWithoutProposalsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProposalsInput
  create: UserCreateWithoutProposalsInput
}

input UserCreateNestedOneWithoutServicesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutServicesInput
  create: UserCreateWithoutServicesInput
}

input UserCreateNestedOneWithoutVotesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVotesInput
  create: UserCreateWithoutVotesInput
}

input UserCreateOrConnectWithoutProposalsInput {
  create: UserCreateWithoutProposalsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutServicesInput {
  create: UserCreateWithoutServicesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutVotesInput {
  create: UserCreateWithoutVotesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutProposalsInput {
  id: String
  name: String!
  services: OwnershipCreateNestedManyWithoutUserInput
  votes: VoteCreateNestedManyWithoutAuthorInput
}

input UserCreateWithoutServicesInput {
  id: String
  name: String!
  proposals: ProposalCreateNestedManyWithoutAuthorInput
  votes: VoteCreateNestedManyWithoutAuthorInput
}

input UserCreateWithoutVotesInput {
  id: String
  name: String!
  proposals: ProposalCreateNestedManyWithoutAuthorInput
  services: OwnershipCreateNestedManyWithoutUserInput
}

input UserOrderByInput {
  id: SortOrder
  name: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserRole {
  DEVELOPER
  INNER_USER
  OUTER_USER
  ROOT
}

enum UserScalarFieldEnum {
  id
  name
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: StringFilter
  name: StringFilter
  proposals: ProposalListRelationFilter
  services: OwnershipListRelationFilter
  votes: VoteListRelationFilter
}

input UserWhereUniqueInput {
  id: String
}

type Vote {
  author: User!
  authorId: String!
  comment: String!
  id: String!
  proposal: Proposal!
  proposalAuthorId: String!
  proposalServiceId: String!
}

input VoteCreateInput {
  author: UserCreateNestedOneWithoutVotesInput!
  comment: String!
  id: String
  proposal: ProposalCreateNestedOneWithoutVoteInput!
}

input VoteCreateManyAuthorInput {
  comment: String!
  id: String
  proposalAuthorId: String!
  proposalServiceId: String!
}

input VoteCreateManyAuthorInputEnvelope {
  data: [VoteCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input VoteCreateManyProposalInput {
  authorId: String!
  comment: String!
  id: String
}

input VoteCreateManyProposalInputEnvelope {
  data: [VoteCreateManyProposalInput!]!
  skipDuplicates: Boolean
}

input VoteCreateNestedManyWithoutAuthorInput {
  connect: [VoteWhereUniqueInput!]
  connectOrCreate: [VoteCreateOrConnectWithoutAuthorInput!]
  create: [VoteCreateWithoutAuthorInput!]
  createMany: VoteCreateManyAuthorInputEnvelope
}

input VoteCreateNestedManyWithoutProposalInput {
  connect: [VoteWhereUniqueInput!]
  connectOrCreate: [VoteCreateOrConnectWithoutProposalInput!]
  create: [VoteCreateWithoutProposalInput!]
  createMany: VoteCreateManyProposalInputEnvelope
}

input VoteCreateOrConnectWithoutAuthorInput {
  create: VoteCreateWithoutAuthorInput!
  where: VoteWhereUniqueInput!
}

input VoteCreateOrConnectWithoutProposalInput {
  create: VoteCreateWithoutProposalInput!
  where: VoteWhereUniqueInput!
}

input VoteCreateWithoutAuthorInput {
  comment: String!
  id: String
  proposal: ProposalCreateNestedOneWithoutVoteInput!
}

input VoteCreateWithoutProposalInput {
  author: UserCreateNestedOneWithoutVotesInput!
  comment: String!
  id: String
}

input VoteListRelationFilter {
  every: VoteWhereInput
  none: VoteWhereInput
  some: VoteWhereInput
}

input VoteOrderByInput {
  authorId: SortOrder
  comment: SortOrder
  id: SortOrder
  proposalAuthorId: SortOrder
  proposalServiceId: SortOrder
}

enum VoteScalarFieldEnum {
  authorId
  comment
  id
  proposalAuthorId
  proposalServiceId
}

input VoteWhereInput {
  AND: [VoteWhereInput!]
  NOT: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  author: UserRelationFilter
  authorId: StringFilter
  comment: StringFilter
  id: StringFilter
  proposal: ProposalRelationFilter
  proposalAuthorId: StringFilter
  proposalServiceId: StringFilter
}

input VoteWhereUniqueInput {
  id: String
}
